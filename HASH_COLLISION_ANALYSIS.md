# ハッシュ衝突対応手法の分析と車載システムへの適用

## 概要

車両CANデータ共有メモリシステムにおけるハッシュ衝突問題の分析と解決策の検討結果をまとめる。現在の上書き方式による致命的なデータロス問題を解決し、車載システムに適した高性能・高信頼性のハッシュテーブル実装を目指す。

---

## 1. 現在の問題点

### 1.1 ハッシュ衝突による上書き方式の問題

現在の実装では、異なるCAN IDが同じハッシュ値を持つ場合、後から来たデータが警告なく前のデータを上書きしてしまう。

```c
// 現在の問題のある実装
uint32_t idx = can_id_hash(can_id);  // ハッシュ値計算
CANBucket* bucket = &g_shm_ptr->buckets[idx];

// 問題：同じバケットに別のCAN IDがあっても上書きしてしまう
bucket->can_data.can_id = can_id;  // データ上書き！
```

**具体例：**
```
CAN ID 0x123    → hash() → バケット[100]
CAN ID 0x456ABC → hash() → バケット[100]  ← 衝突！

結果: 0x123のデータが失われ、0x456ABCのデータのみ残る
```

### 1.2 車載システムでの致命的な影響

- **サイレントなデータロス**: エラー通知なしにデータが消失
- **デバッグ困難**: 間欠的な不具合の原因特定が困難
- **安全性リスク**: 車両制御に関わるデータの欠損による危険性

---

## 2. ハッシュ衝突解決手法の比較

### 2.1 手法一覧

| 手法 | 衝突解決 | メモリ効率 | 性能 | 拡張性 | 実装難易度 | 車載適用 |
|------|---------|----------|------|--------|----------|---------|
| **リニアプロービング** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ✅**推奨** |
| 完全ハッシュ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐ | ⭐⭐ | △ 限定的 |
| 二次プロービング | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | △ 複雑 |
| ダブルハッシュ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐ | △ 高コスト |
| チェイン法 | ⭐⭐⭐ | ⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐ | ❌ 不適合 |
| 現在の上書き | ❌ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ❌ 危険 |

### 2.2 リニアプロービング法（推奨解決策）

#### 基本アルゴリズム
```c
// 改良版 can_shm_set() の動作
uint32_t hash = can_id_hash(can_id);

for (int i = 0; i < 4096; i++) {
    uint32_t idx = (hash + i) % 4096;  // 順番に探査
    CANBucket* bucket = &g_shm_ptr->buckets[idx];
    
    pthread_mutex_lock(&bucket->mutex);
    
    if (bucket->is_valid == 0) {
        // 空きバケット発見 → データ格納
        bucket->can_data.can_id = can_id;
        // ... データ設定
        bucket->is_valid = 1;
        pthread_mutex_unlock(&bucket->mutex);
        return CAN_SHM_SUCCESS;
    }
    else if (bucket->can_data.can_id == can_id) {
        // 同じCAN IDの更新 → データ上書き
        // ... データ更新
        pthread_mutex_unlock(&bucket->mutex);
        return CAN_SHM_SUCCESS;
    }
    
    pthread_mutex_unlock(&bucket->mutex);
    // 別のCAN IDが使用中 → 次のバケットを探す
}

return CAN_SHM_ERROR_TABLE_FULL;  // 満杯エラー
```

#### 動作例
```
初期状態：
バケット[98]: [空き]
バケット[99]: [空き] 
バケット[100]: [空き]
バケット[101]: [空き]

CAN ID 0x123 → hash() → 100番
バケット[100]: [0x123のデータ] ✓

CAN ID 0x456ABC → hash() → 100番（衝突！）
バケット[100]: [0x123使用中] → 次を探す
バケット[101]: [空き] → ここに格納 ✓

結果：
バケット[100]: [0x123のデータ]
バケット[101]: [0x456ABCのデータ]  ← 両方保存される！
```

#### メリット・デメリット

**メリット：**
- **データロス完全防止** - 衝突してもデータが失われない
- **実装がシンプル** - ループで順番に探すだけ
- **メモリ効率** - 追加のポインタ構造が不要
- **キャッシュ効率** - 連続メモリアクセス

**デメリット：**
- **クラスタリング** - 連続するバケットが埋まりやすい
- **削除の複雑さ** - 単純に削除すると探査チェーンが切れる
- **負荷率依存** - テーブルが満杯に近いと性能低下

### 2.3 その他の手法

#### チェイン法（Separate Chaining）
- **概要**: 各バケットに連結リストを持たせ、衝突したデータを繋げる
- **車載適用性**: ❌ 共有メモリ環境では実装困難
- **理由**: ポインタが別プロセスで無効、メモリ断片化

#### 完全ハッシュ（Perfect Hashing）
- **概要**: 衝突が全く発生しないハッシュ関数を事前に構築
- **適用条件**: 11bit CAN専用システム
- **車載適用性**: ⭐⭐⭐ 標準CAN（11bit）なら最適
- **制限**: CAN IDの範囲が限定、拡張CAN不対応

---

## 3. C++ STLとの比較

### 3.1 std::unordered_map の実装

#### 採用アルゴリズム
- **アルゴリズム**: チェイン法（Separate Chaining）
- **実装**: GCC libstdc++、Clang libc++、MSVC STL すべて

#### なぜオープンアドレス法を使わないのか？

**1. C++標準の厳しい要求事項**
```cpp
// C++標準の要求：削除時に他のイテレータを無効化してはいけない
std::unordered_map<int, std::string> map;
auto it1 = map.insert({1, "one"}).first;
auto it2 = map.insert({2, "two"}).first;

map.erase(2);  // key=2を削除
// 標準の要求：it1は依然として有効でなければならない
std::cout << it1->second << std::endl;  // "one" が出力されるべき
```

**2. オープンアドレス法の問題**
- 削除時に要素移動が発生 → イテレータ無効化
- 例外安全性の実装が困難
- 任意の型への対応が複雑

**3. 設計哲学の違い**

| 観点 | C++ STL | 車載システム |
|------|---------|-------------|
| **優先度** | 汎用性・安全性 | 性能・予測性 |
| **型制約** | 最小限 | 制御可能 |
| **例外** | 強い保証必須 | 例外禁止 |
| **動的拡張** | 必須 | 不要 |
| **イテレータ** | 安定性重視 | 使用しない |

### 3.2 車載システムでSTLが適用困難な理由

#### 動的メモリ確保の問題
```cpp
std::unordered_map<uint32_t, CANData> can_map;

// 実行時に動的にメモリ確保
can_map[0x123] = data1;  // new で内部ノード作成
can_map[0x456] = data2;  // malloc でバケット拡張
can_map[0x789] = data3;  // リハッシュでメモリ再確保

// 問題：
// 1. ヒープ使用 → 組み込みNG
// 2. 実行時サイズ変動 → 共有メモリNG
// 3. メモリ断片化 → リアルタイムNG
```

#### 共有メモリ制約との衝突
```c
// 共有メモリは起動時にサイズ固定
SharedMemoryLayout* shm = mmap(NULL, 
    sizeof(SharedMemoryLayout),  // ←固定サイズ必須
    PROT_READ | PROT_WRITE,
    MAP_SHARED, fd, 0);

// unordered_mapの問題点
std::unordered_map<uint32_t, CANData> map;
// → サイズが予測不可能
// → 共有メモリに配置不可能
```

---

## 4. 車載システムでの適用条件

### 4.1 オープンアドレス法が最適な理由

#### 車載CAN IDの特性
```c
// 車種固定のCAN ID例
// トヨタ プリウス: 約3500個のCAN ID
// BMW X5: 約4200個のCAN ID
// テスラ Model 3: 約2800個のCAN ID

// 設計例：最大4000個のIDに対して
CANBucket buckets[8192];  // 2倍の余裕 (負荷率50%)
// → ほぼO(1)での検索保証
```

#### 負荷率と性能の関係
```c
// 負荷率 = 使用ID数 / バケット数
float load_factor = 4000.0 / 8192.0;  // = 0.49 (49%)

// 平均探査回数
// 負荷率25%: 1.33回
// 負荷率50%: 2.00回  ← 現実的
// 負荷率75%: 4.00回  ← 性能劣化開始
// 負荷率90%: 10.0回  ← 使用不可
```

### 4.2 適用場面の比較

| 特徴 | 車載システム | Webサーバー |
|------|-------------|------------|
| **ID数** | **固定** (車種で決定) | **不定** (ユーザー依存) |
| **予測可能性** | ✅ 完全予測可能 | ❌ 予測困難 |
| **オープンアドレス法** | ✅ **最適** | ❌ 不適 |
| **チェイン法** | △ オーバーヘッド | ✅ **最適** |

---

## 5. 実装選択肢

### 5.1 自作実装（推奨案1）

#### 特徴
- 既存のC言語コードベースを活用
- 外部依存なし
- 完全制御可能
- 車載要件に最適化

#### 実装コスト
- **開発**: 中程度（リニアプロービング実装）
- **テスト**: 中程度（既存テストケース拡張）
- **保守**: 低程度（シンプルなアルゴリズム）

### 5.2 ETL (Embedded Template Library) 使用（推奨案2）

#### ライブラリ情報
- **ライセンス**: MIT License（商用利用完全フリー）
- **開発形態**: コミュニティベース（主導：John Wellbelove氏）
- **GitHub統計**: ⭐2.5k, 🍴453, 👥141 contributors

#### 車載システム適合性
- **動的メモリ確保ゼロ**: コンパイル時サイズ決定
- **例外処理なし**: MISRA C++ Rule 15-3-2 対応
- **RTTI不使用**: MISRA C++ Rule 5-2-2 対応
- **決定論的動作**: ISO 26262 ASIL要求対応

#### 使用例
```cpp
#include "etl/unordered_map.h"

// 静的メモリ確保、動的確保なし
etl::unordered_map<uint32_t, CANData, 4096> can_map;

extern "C" {
    CANShmResult can_shm_set(uint32_t can_id, uint16_t dlc, const uint8_t* data) {
        CANData can_data = {/* ... */};
        can_map[can_id] = can_data;
        return CAN_SHM_SUCCESS;
    }
}
```

#### リスク評価

**メリット：**
- 完全フリー（ライセンス問題なし）
- 車載特化設計（MISRA/ISO 26262対応）
- 高い安定性（10年の実績）
- 活発なメンテナンス

**懸念点：**
- 企業サポートなし（有償サポート不可）
- 主要開発者への依存
- 公式LTSなし（長期保証なし）

### 5.3 RTTIについて

#### RTTIとは
**RTTI (Run-Time Type Information)** は「実行時型情報」のことで、C++プログラムが実行中にオブジェクトの型情報を取得・判定できる機能。

#### 車載システムでRTTIが問題となる理由

**1. メモリオーバーヘッド**
- 各クラスに型情報テーブルが追加される
- 限られたメモリリソースの圧迫

**2. 実行時オーバーヘッド**
```cpp
// 時間がかかる操作
if (typeid(*obj) == typeid(SpecificClass)) {
    // 文字列比較やハッシュ計算が発生
}
```

**3. 決定論的でない動作**
- 実装依存の型名生成
- 予測困難な実行時間

#### MISRA C++での制限
- **MISRA C++ Rule 5-2-2**: RTTIの使用禁止
- 理由：予測不可能な実行時間、実装依存の動作

---

## 6. 推奨実装方針

### 6.1 車載プロジェクトでの最終推奨

**車載プロジェクトの性質により判断：**

1. **スタートアップ・小規模**: ETL推奨 ⭐⭐⭐
2. **大企業・量産車**: 慎重検討 ⭐⭐
3. **ASIL-D/高安全**: 自作実装推奨 ⭐⭐⭐

### 6.2 設計指針

#### 設計時の決定プロセス
```c
// ステップ1: 車種のCAN DB解析
// DBC ファイルから CAN ID 抽出
// 例：Engine ECU: 50個、Body ECU: 200個...
// 合計：3847個のCAN ID

// ステップ2: バケット数決定
#define MAX_CAN_IDS 4096      // 余裕を持った上限
#define BUCKET_COUNT 8192     // 2倍の配列確保
// 負荷率 = 4096/8192 = 50% (理想的)

// ステップ3: ハッシュテーブル設計
typedef struct {
    CANBucket buckets[BUCKET_COUNT];
} SharedCANTable;
```

#### 性能目標
- **Set操作**: 1μs以内（典型値）
- **Get操作**: 500ns以内（ロックフリー読み取り）
- **負荷率**: 50%以下を維持
- **探査回数**: 平均2回以内

---

## 7. まとめ

### 7.1 問題解決の要点

1. **現在の致命的問題**: ハッシュ衝突時の上書きによるデータロス
2. **最適解決策**: リニアプロービング法の採用
3. **車載適合性**: ID数固定、固定サイズメモリ、高性能要求に最適
4. **実装選択**: 自作実装またはETL使用

### 7.2 技術的な理解

- **車載システム**: ID固定 → オープンアドレス法 + 2倍配列で概ねO(1)
- **不定IDシステム**: ID変動 → チェイン法（std::unordered_map）が適切
- **C++ STL**: 汎用性・安全性重視のためチェイン法採用
- **車載共有メモリ**: 性能・予測性重視のためオープンアドレス法が最適

### 7.3 次のステップ

1. **詳細設計**: リニアプロービング法の具体的実装設計
2. **性能評価**: ベンチマークテストの実施
3. **テスト戦略**: 衝突パターンを含む包括的テスト計画
4. **移行計画**: 既存システムからの段階的移行戦略

---

*文書作成日: 2025-07-02*  
*対象システム: 車両CANデータ共有メモリシステム v1.0*